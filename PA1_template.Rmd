---
title: "Reproducible Research: Peer Assessment 1"
output: 
  html_document:
    keep_md: true
---

```{r setoptions,echo=FALSE}
# When numbers are displayed in this document, we prefer not to use scientific
# notation like 1.5e4 unless the numbers are very large.
options(scipen=7)
```

## Loading and preprocessing the data

The data comes as a zip file containing a single comma-separated values (csv)
file.

```{r}
# Unpack the data, if not already done
dataName <- "activity.csv"
zipName <- sub(".csv", ".zip", dataName)
if (!file.exists(dataName)) {
    unzip(zipName)
}

dat <- read.csv("activity.csv",
                colClasses=c("integer", "character", "integer"))
head(dat)
```


## What is mean total number of steps taken per day?

Filter out missing values, then group by date, then sum up steps on each date.

```{r message=FALSE}
library(dplyr)
stepsByDay <- dat %>% filter(complete.cases(.)) %>% group_by(date) %>%
    summarize(steps=sum(steps))
library(ggplot2)
qplot(stepsByDay$steps, geom="histogram", xlab="Number of steps in a day")
stepsByDaySummary <- summary(stepsByDay$steps)
meanStepsByDay <- round(stepsByDaySummary["Mean"])
medianStepsByDay <- round(stepsByDaySummary["Median"])
```

The mean number of steps per day is `r meanStepsByDay`.
The median number of steps per day is `r medianStepsByDay`.


## What is the average daily activity pattern?

From the range of the "interval" variable it looks like that variable codes
hours and minutes in 24-hour format.

```{r}
range(dat$interval)
# Just the first two digits
range(floor(dat$interval/100))
# Just the last two digits
range(dat$interval %% 100)
```

So we don't want to use "interval" as is on the x-axis: there would be big gaps
between 1255 and 1300, for example, when those two intervals should be right next to
each other. Convert "interval" to a time.

```{r}
# The group_by function used below wants times in POSIXct format. The sprintf
# function here makes the number from "interval" 4 digits long (e.g. 15 becomes
# "0015") before trying to interpret it as a time of day.
dat$betterInterval <- as.POSIXct(sprintf("%04d", dat$interval),
                                 tz="GMT", "%H%M")
stepsByInterval <- dat %>% filter(complete.cases(.)) %>%
    group_by(betterInterval) %>% summarize(steps=mean(steps))

# Use the scales library to be able to format the x-axis as just times.
library(scales)
ggplot(stepsByInterval, aes(x=betterInterval, y=steps)) +
    geom_line() +
    labs(x="Interval", y="Average number of steps in interval") +
    scale_x_datetime(labels=date_format("%H:%M"))

intervalWithMaxSteps <- dat[which.max(stepsByInterval$steps),]$interval
```

Interval `r intervalWithMaxSteps` contains the maximum number of steps.


## Imputing missing values



## Are there differences in activity patterns between weekdays and weekends?
